module ppa4bit (A, B, Cin, S, Cout);  
  input [3:0] A, B;                                 
  input Cin;
  output [3:0] S;
  output Cout;
  
  wire [3:0] P, G;  
  wire c1, c2, c3;  
  
  assign P = A ^ B;
  assign G = A & B;
  
  assign c1 = G[0] | (P[0] & Cin);
  assign c2 = G[1] | (P[1] & c1);
  assign c3 = G[2] | (P[2] & c2);
  assign Cout = G[3] | (P[3] & c3);
  
  assign S[0] = P[0] ^ Cin;
  assign S[1] = P[1] ^ c1;
  assign S[2] = P[2] ^ c2;
  assign S[3] = P[3] ^ c3;

endmodule 


module ppa16bit (A, B, Cin, S, Cout);  
  input [15:0] A, B;   
  input Cin;           
  output [15:0] S;    
  output Cout;         
  
  wire c1, c2, c3, c4, c5, c6, c7, c8;  

  ppa4bit PPA0(A[3:0],B[3:0],Cin,S[3:0],c1);
  ppa4bit PPA1(A[7:4],B[7:4],c1,S[7:4],c2);
  ppa4bit PPA2(A[11:8],B[11:8],c2,S[11:8],c3);
  ppa4bit PPA3(A[15:12],B[15:12],c3,S[15:12],Cout);

endmodule

*************************************************************

module bit16PPA(A, B, Cin, S, Cout);
    input [15:0] A, B;
    input Cin;
    output [15:0] S;
    output Cout;
    
    wire [15:0] G, P, C;
    wire [15:0] Gp, Pp;
    
    assign G = A & B;  // Generating G (Generate) signals
    assign P = A | B;  // Generating P (Propagate) signals
    
    // Generate the Gp (carry propagate) and Pp (carry propagate) signals for each bit
    assign Gp[0] = G[0] | (P[0] & Cin);
    assign Pp[0] = P[0];
    
    assign Gp[1] = G[1] | (P[1] & Gp[0]);
    assign Pp[1] = P[1] & Pp[0];
    
    assign Gp[2] = G[2] | (P[2] & Gp[1]);
    assign Pp[2] = P[2] & Pp[1];
    
    assign Gp[3] = G[3] | (P[3] & Gp[2]);
    assign Pp[3] = P[3] & Pp[2];
    
    assign Gp[4] = G[4] | (P[4] & Gp[3]);
    assign Pp[4] = P[4] & Pp[3];
    
    assign Gp[5] = G[5] | (P[5] & Gp[4]);
    assign Pp[5] = P[5] & Pp[4];
    
    assign Gp[6] = G[6] | (P[6] & Gp[5]);
    assign Pp[6] = P[6] & Pp[5];
    
    assign Gp[7] = G[7] | (P[7] & Gp[6]);
    assign Pp[7] = P[7] & Pp[6];
    
    assign Gp[8] = G[8] | (P[8] & Gp[7]);
    assign Pp[8] = P[8] & Pp[7];
    
    assign Gp[9] = G[9] | (P[9] & Gp[8]);
    assign Pp[9] = P[9] & Pp[8];
    
    assign Gp[10] = G[10] | (P[10] & Gp[9]);
    assign Pp[10] = P[10] & Pp[9];
    
    assign Gp[11] = G[11] | (P[11] & Gp[10]);
    assign Pp[11] = P[11] & Pp[10];
    
    assign Gp[12] = G[12] | (P[12] & Gp[11]);
    assign Pp[12] = P[12] & Pp[11];
    
    assign Gp[13] = G[13] | (P[13] & Gp[12]);
    assign Pp[13] = P[13] & Pp[12];
    
    assign Gp[14] = G[14] | (P[14] & Gp[13]);
    assign Pp[14] = P[14] & Pp[13];
    
    assign Gp[15] = G[15] | (P[15] & Gp[14]);
    assign Pp[15] = P[15] & Pp[14];
    
    // Step 3: Compute the sum
    
    
    // Generate carry bits for each bit position
    // Wouldnt these bits need more than just Gp? Including Pp in could help.
    assign C[0] = Cin; 
    assign C[1] = Gp[0]; 
    assign C[2] = Gp[1]; 
    assign C[3] = Gp[2];
    assign C[4] = Gp[3];
    assign C[5] = Gp[4];
    assign C[6] = Gp[5];
    assign C[7] = Gp[6];
    assign C[8] = Gp[7];
    assign C[9] = Gp[8];
    assign C[10] = Gp[9];
    assign C[11] = Gp[10];
    assign C[12] = Gp[11];
    assign C[13] = Gp[12];
    assign C[14] = Gp[13];
    assign C[15] = Gp[14];   
    
    assign Cout = Gp[15];

    // Maybe use P instead of G?
    assign S = G ^ C;
    
endmodule
